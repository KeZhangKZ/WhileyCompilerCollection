package wybs.lang;

import java.io.IOException;
import java.util.Collection;
import java.util.Set;

import wyfs.lang.Path;
import wyfs.lang.Path.Entry;

/**
 * <p>
 * A build rule is an abstraction describing how a set of one or more source
 * files should be compiled. Each build rule is associated with a build task
 * responsible for compiling matching files, a destination root and a
 * mechanism for "matching source" files. For example, we could view a build
 * rule like this:
 * </p>
 * 
 * <pre>
 * WhileyCompiler :: src/:whiley/lang/*.whiley => bin/
 * </pre>
 * 
 * <p>
 * Here, the build task is the <code>WhileyCompiler</code>, whilst the
 * destination root is "bin/". Source files are taken from the root "src/"
 * matching the regex "whiley/lang/*.whiley".
 * </p>
 * 
 * <p>
 * Different build rules are free to implement the "matching" mechanism as
 * they wish. Typically, one wants a generic way to describe a group of
 * source files using wildcards (often called the "includes"). Occasionally,
 * one also wants a way to exclude one or more files (oftern called the
 * "excludes").
 * </p>
 * 
 * @author David J. Pearce
 * 
 */
public interface BuildRule {

	/**
	 * <p>
	 * Apply this rule to a given compilation group, producing a set of
	 * generated or modified files. This set may be empty if the rule does
	 * not match against any source file in the group.
	 * </p>
	 * 
	 * @param The
	 *            set of files currently being compiled.
	 * @return The set of files generated by this rule (which may be empty,
	 *         but cannot be <code>null</code>).
	 * @throws IOException
	 */
	public Set<Path.Entry<?>> apply(Collection<? extends Path.Entry<?>> group)
			throws IOException;
}